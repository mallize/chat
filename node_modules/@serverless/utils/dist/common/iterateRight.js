"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.baseIterateRight = exports.default = void 0;

var _isResolved = require("./isResolved");

var _resolveWith = require("./resolveWith");

var _curry = _interopRequireDefault(require("./curry"));

var _isFunction = _interopRequireDefault(require("../lang/isFunction"));

var _iterator = _interopRequireWildcard(require("./iterator"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const resolveNext = (next, fn, iter, recur) => (0, _resolveWith.baseResolveWith)(resolvedNext => {
  if (resolvedNext.done) {
    return resolvedNext.value;
  }

  return recur(fn, iter);
}, next);

const doReverseSeriesIteration = (fn, iter) => {
  while (true) {
    let next = iter.previous();

    if (!(0, _isResolved.baseIsResolved)(next)) {
      return (0, _resolveWith.baseResolveWith)(resolvedNext => {
        next = fn(resolvedNext);

        if (!(0, _isResolved.baseIsResolved)(next)) {
          return resolveNext(next, fn, iter, doReverseSeriesIteration);
        }

        if (next.done) {
          return next.value;
        }

        return doReverseSeriesIteration(fn, iter);
      }, next);
    }

    next = fn(next);

    if (!(0, _isResolved.baseIsResolved)(next)) {
      return resolveNext(next, fn, iter, doReverseSeriesIteration);
    }

    if (next.done) {
      return next.value;
    }
  }
};

const baseIterateRight = (iteratee, collection) => {
  const iter = (0, _iterator.baseIterator)(collection, _iterator.default.END);

  if (!(0, _isFunction.default)(iter.previous)) {
    throw new Error(`iterateRight expects an iterator that can be run in reverse order using a 'previous' method. Instead received ${iter}`);
  }

  return doReverseSeriesIteration(iteratee, iter);
};
/**
 * This method iterates over the given collection or iterator in **series**. If the `iteratee` method returns `{ done: true }` then the iteration will complete.
 *
 * This method automatically upgrades to async. If the `iteratee` returns a Promise or a generator, this method will return a Promise or a generator. Values are iterated in order and if the iteratee returns a resolvable value the iteration will wait until that value resolves before continuing with the iteration.
 *
 * This method also supports async iterators. If an unresolved value is received from the iterator instead of an object with `value` and `done` properties, the iteration will wait for the value to resolve before continuing to the next iteration. This will also cause the method to upgrade to async and return a Promise.
 *
 * @function
 * @since v0.0.11
 * @category common
 * @param {Function} iteratee The iteratee Function
 * @param  {*} collection The collection or iterator to iterate over
 * @returns {*} The final value returned when the iteratee returns done or `undefined`
 * @example
 *
 * iterateRight((value, kdx) => {
 *   if (value === 'b') {
 *     return { done: true, value: kdx }
 *   }
 *   return { done: false }
 * }, ['a', 'b', 'c'])
 * //=> 1
 *
 * iterateRight(async (value, kdx) => new Promise((resolve, reject) => {
 *   setTimeout(() => {
 *     if (value === 'b') {
 *       return resolve({ done: true, value: kdx })
 *     }
 *     return resolve({ done: false })
 *   }, 0)
 * }), ['a', 'b', 'c'])
 * //=> 1
 */


exports.baseIterateRight = baseIterateRight;
const iterateRight = (0, _curry.default)(baseIterateRight);
var _default = iterateRight;
exports.default = _default;
//# sourceMappingURL=iterateRight.js.map