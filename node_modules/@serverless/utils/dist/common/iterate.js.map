{"version":3,"sources":["../../src/common/iterate.js"],"names":["resolveNext","next","fn","iter","recur","resolvedNext","done","value","doSeriesIteration","baseIterate","iteratee","collection","iterate"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,WAAW,GAAG,CAACC,IAAD,EAAOC,EAAP,EAAWC,IAAX,EAAiBC,KAAjB,KAClB,kCAAiBC,YAAD,IAAkB;AAChC,MAAIA,YAAY,CAACC,IAAjB,EAAuB;AACrB,WAAOD,YAAY,CAACE,KAApB;AACD;;AACD,SAAOH,KAAK,CAACF,EAAD,EAAKC,IAAL,CAAZ;AACD,CALD,EAKGF,IALH,CADF;;AAQA,MAAMO,iBAAiB,GAAG,CAACN,EAAD,EAAKC,IAAL,KAAc;AACtC,SAAO,IAAP,EAAa;AACX,QAAIF,IAAI,GAAGE,IAAI,CAACF,IAAL,EAAX;;AACA,QAAI,CAAC,gCAAeA,IAAf,CAAL,EAA2B;AACzB,aAAO,kCAAiBI,YAAD,IAAkB;AACvCJ,QAAAA,IAAI,GAAGC,EAAE,CAACG,YAAD,CAAT;;AACA,YAAI,CAAC,gCAAeJ,IAAf,CAAL,EAA2B;AACzB,iBAAOD,WAAW,CAACC,IAAD,EAAOC,EAAP,EAAWC,IAAX,EAAiBK,iBAAjB,CAAlB;AACD;;AACD,YAAIP,IAAI,CAACK,IAAT,EAAe;AACb,iBAAOL,IAAI,CAACM,KAAZ;AACD;;AACD,eAAOC,iBAAiB,CAACN,EAAD,EAAKC,IAAL,CAAxB;AACD,OATM,EASJF,IATI,CAAP;AAUD;;AACDA,IAAAA,IAAI,GAAGC,EAAE,CAACD,IAAD,CAAT;;AACA,QAAI,CAAC,gCAAeA,IAAf,CAAL,EAA2B;AACzB,aAAOD,WAAW,CAACC,IAAD,EAAOC,EAAP,EAAWC,IAAX,EAAiBK,iBAAjB,CAAlB;AACD;;AACD,QAAIP,IAAI,CAACK,IAAT,EAAe;AACb,aAAOL,IAAI,CAACM,KAAZ;AACD;AACF;AACF,CAvBD;;AAyBA,MAAME,WAAW,GAAG,CAACC,QAAD,EAAWC,UAAX,KAA0BH,iBAAiB,CAACE,QAAD,EAAW,4BAAaC,UAAb,CAAX,CAA/D;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,MAAMC,OAAO,GAAG,oBAAMH,WAAN,CAAhB;eAEeG,O","sourcesContent":["import { baseIsResolved } from './isResolved'\nimport { baseIterator } from './iterator'\nimport { baseResolveWith } from './resolveWith'\nimport curry from './curry'\n\nconst resolveNext = (next, fn, iter, recur) =>\n  baseResolveWith((resolvedNext) => {\n    if (resolvedNext.done) {\n      return resolvedNext.value\n    }\n    return recur(fn, iter)\n  }, next)\n\nconst doSeriesIteration = (fn, iter) => {\n  while (true) {\n    let next = iter.next()\n    if (!baseIsResolved(next)) {\n      return baseResolveWith((resolvedNext) => {\n        next = fn(resolvedNext)\n        if (!baseIsResolved(next)) {\n          return resolveNext(next, fn, iter, doSeriesIteration)\n        }\n        if (next.done) {\n          return next.value\n        }\n        return doSeriesIteration(fn, iter)\n      }, next)\n    }\n    next = fn(next)\n    if (!baseIsResolved(next)) {\n      return resolveNext(next, fn, iter, doSeriesIteration)\n    }\n    if (next.done) {\n      return next.value\n    }\n  }\n}\n\nconst baseIterate = (iteratee, collection) => doSeriesIteration(iteratee, baseIterator(collection))\n\n/**\n * This method iterates over the given collection or iterator in **series**. If the `iteratee` method returns `{ done: true }` then the iteration will complete.\n *\n * This method automatically upgrades to async. If the `iteratee` returns a Promise or a generator, this method will return a Promise or a generator. Values are iterated in order and if the iteratee returns a resolvable value the iteration will wait until that value resolves before continuing with the iteration.\n *\n * This method also supports async iterators. If an unresolved value is received from the iterator instead of an object with `value` and `done` properties, the iteration will wait for the value to resolve before continuing to the next iteration. This will also cause the method to upgrade to async and return a Promise.\n *\n * @function\n * @since v0.0.11\n * @category common\n * @param {Function} iteratee The iteratee Function\n * @param  {*} collection The collection or iterator to iterate over\n * @returns {*} The final value returned when the iteratee returns done or `undefined`\n * @example\n *\n * iterate((value, kdx) => {\n *   if (value === 'b') {\n *     return { done: true, value: kdx }\n *   }\n *   return { done: false }\n * }, ['a', 'b', 'c'])\n * //=> 1\n *\n * iterate(async (value, kdx) => new Promise((resolve, reject) => {\n *   setTimeout(() => {\n *     if (value === 'b') {\n *       return resolve({ done: true, value: kdx })\n *     }\n *     return resolve({ done: false })\n *   }, 0)\n * }), ['a', 'b', 'c'])\n * //=> 1\n */\nconst iterate = curry(baseIterate)\n\nexport default iterate\n\nexport { baseIterate }\n"],"file":"iterate.js"}