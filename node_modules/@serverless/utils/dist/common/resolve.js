"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.baseResolve = exports.default = void 0;

var _isResolved = require("./isResolved");

var _resolveToGenerator = require("./resolveToGenerator");

var _curry = _interopRequireDefault(require("./curry"));

var _isFunction = _interopRequireDefault(require("../lang/isFunction"));

var _isPromise = _interopRequireDefault(require("../lang/isPromise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const baseResolve = value => {
  if (!(0, _isResolved.baseIsResolved)(value)) {
    if ((0, _isFunction.default)(value.resolve)) {
      return baseResolve(value.resolve());
    }

    if ((0, _isPromise.default)(value)) {
      return value.then(resolved => baseResolve(resolved));
    }

    return (0, _resolveToGenerator.baseResolveToGenerator)(value);
  }

  return value;
};
/**
 * Resolves a value to its valueOf.
 *
 * Dispatches to the `resolve` method if it exists. If a resolve method returns a value that is also resolvable, this method will resolve that value as well.
 *
 * @function
 * @since v0.0.9
 * @category common
 * @sig [String] -> {a} -> String
 * @param {...String} values The values to check.
 * @returns {String} The first value found that is a path.
 * @example
 *
 * resolve('foo') // => 'foo'
 *
 * resolve({
 *  valueOf: () => 'bar'
 * }) //=> bar
 *
 * resolve({
 *  resolve: () => 'bar'
 * }) //=> bar
 *
 * resolve({
 *   resolve: () => ({
 *     valueOf: () => 'bar'
 *   })
 * }) //=> bar
 *
 * resolve({
 *   resolve: () => ({
 *     resolve: () => 'bar'
 *   })
 * }) //=> bar
 */


exports.baseResolve = baseResolve;
const resolve = (0, _curry.default)(baseResolve);
var _default = resolve;
exports.default = _default;
//# sourceMappingURL=resolve.js.map