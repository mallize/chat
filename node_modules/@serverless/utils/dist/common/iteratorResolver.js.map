{"version":3,"sources":["../../src/common/iteratorResolver.js"],"names":["iterateAt","iterator","history","pending","index","next","resolvedNext","done","fastForward","histIterator","iterAt","iter","kdx","prevIterAt","historicIterator","start","resolvedIter","prev","previous","iteratorResolver","TypeError","resolvedIterator"],"mappings":"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","sourcesContent":["import { baseIsResolved } from './isResolved'\nimport { baseResolveWith } from './resolveWith'\nimport isIterator from '../lang/isIterator'\nimport toString from '../lang/toString'\n\nconst iterateAt = (iterator, history, pending, index) => {\n  if (history[index]) {\n    return history[index]\n  }\n  if (pending[index]) {\n    return pending[index]\n  }\n  const next = iterator.next()\n  pending[index] = next\n  history[index] = null\n  return baseResolveWith((resolvedNext) => {\n    pending[index] = null\n    if (!resolvedNext.done) {\n      history[index] = resolvedNext\n    }\n    return resolvedNext\n  }, next)\n}\n\nconst fastForward = (histIterator) => {\n  let next = { done: false }\n  while (!next.done) {\n    next = histIterator.next()\n    if (!baseIsResolved(next)) {\n      return baseResolveWith((resolvedNext) => {\n        if (!resolvedNext.done) {\n          return fastForward(histIterator)\n        }\n        return histIterator\n      }, next)\n    }\n  }\n  return histIterator\n}\n\nconst iterAt = (index, history) => {\n  if (index >= 0 && history[index]) {\n    const iter = history[index]\n    return {\n      ...iter,\n      index,\n      kdx: index\n    }\n  }\n  return {\n    done: true\n  }\n}\n\nconst prevIterAt = (index, history) => {\n  if (index >= 0 && history[index]) {\n    const iter = history[index]\n    return {\n      ...iter,\n      index,\n      kdx: index\n    }\n  }\n}\n\nconst historicIterator = (iterator, start = 'START') => {\n  const history = []\n  const pending = []\n  let index = 0\n\n  const histIterator = {\n    next: () => {\n      const iter = iterateAt(iterator, history, pending, index)\n      return baseResolveWith((resolvedIter) => {\n        const prev = prevIterAt(index - 1, history)\n        if (!resolvedIter.done) {\n          resolvedIter = iterAt(index, history)\n          index += 1\n        }\n        return {\n          ...resolvedIter,\n          prev\n        }\n      }, iter)\n    },\n    previous: () => {\n      const iter = iterAt(index - 1, history)\n      const prev = prevIterAt(index, history)\n      if (index >= 0) {\n        index -= 1\n      }\n      return {\n        ...iter,\n        prev\n      }\n    }\n  }\n\n  if (start === 'END') {\n    return fastForward(histIterator)\n  }\n  return histIterator\n}\n\n/**\n * Returns iterator capable of resolving iterators that might be async, wrapping it in additional functionality.\n *\n * @function\n * @since v0.0.16\n * @category common\n * @param {Iterator} iterator The iterator to wrap\n * @param {string} start The positin to start at.\n * @return {Iterator} A new iterator for the given iterator\n * @example\n *\n * iteratorResolver(\n *  (['write', 'more'])[Symbol.iterator]()\n * )\n * //=> {\n * //   next: () => ({\n * //     value: *,\n * //     done: boolean,\n * //     kdx: integer,\n * //     index: integer\n * //   }),\n * //   previous: () => ({\n * //     value: *,\n * //     done: boolean,\n * //     kdx: integer,\n * //     index: integer\n * //   })\n * // }\n */\nconst iteratorResolver = (iterator, start = 'START') => {\n  if (!isIterator(iterator)) {\n    throw new TypeError(\n      `iteratorResolver expected iterator to be an Iterator value. Instead received ${toString(\n        iterator\n      )}`\n    )\n  }\n\n  // NOTE BRN: Optimization here of reassigning histIterator so that we don't have to resolve it on every iteration.\n  let histIterator\n  histIterator = baseResolveWith((resolvedIterator) => {\n    histIterator = resolvedIterator\n    return histIterator\n  }, historicIterator(iterator, start))\n\n  return {\n    next: () => baseResolveWith((resolvedIterator) => resolvedIterator.next(), histIterator),\n    previous: () => baseResolveWith((resolvedIterator) => resolvedIterator.previous(), histIterator)\n  }\n}\n\nexport default iteratorResolver\n"],"file":"iteratorResolver.js"}