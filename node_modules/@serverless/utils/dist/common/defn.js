"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _allWith = require("./allWith");

var _dispatchable = _interopRequireDefault(require("./dispatchable"));

var _nArySpread = _interopRequireDefault(require("./nArySpread"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Defines a function with a few predefined behaviours. Functions defined with this method will...
 * - [curry](#curry)
 * - [dispatch](#dispatchable)
 * - [resolve all args](#resolveAll)
 *
 * @function
 * @since v0.0.3
 * @category common
 * @sig defn(
 *   name: string,
 *   fn: (*) => any
 * ): (...args: any[], last: any) => last[name] ? last[name](...args) : defaultFn(...args)
 * @param {string} name The name of the method to call if it exists
 * @param {Function} fn The default function to execute if the named one does not exist on the last arg
 * @returns {Function} The wrapped function
 * @example
 *
 * const get = defn('get', (prop, value) => value[prop])
 * get('a', { a: 'foo' }) //=> 'foo'
 *
 * const obj = {
 *   props: {
 *     a: 'bar'
 *   }
 *   get: (prop) => obj.props[prop]
 * }
 * get('a', obj) //=> 'bar'
 */
const defn = (name, fn) => {
  const arity = fn.length;
  const dispatcher = (0, _dispatchable.default)(name, fn);

  const override = function override(...args) {
    return (0, _allWith.baseAllWith)(resolvedArgs => dispatcher.apply(this, resolvedArgs), args);
  };

  return (0, _nArySpread.default)(arity, override);
};

var _default = defn;
exports.default = _default;
//# sourceMappingURL=defn.js.map