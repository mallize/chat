"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.baseResolveToGeneratorWith = exports.default = void 0;

var _isResolved = require("./isResolved");

var _resolve = require("./resolve");

var _resolveToGenerator = require("./resolveToGenerator");

var _curry = _interopRequireDefault(require("./curry"));

var _isGenerator = _interopRequireDefault(require("../lang/isGenerator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const baseResolveToGeneratorWith = function* baseResolveToGeneratorWith(fn, value) {
  if (!(0, _isResolved.baseIsResolved)(value)) {
    value = (0, _resolve.baseResolve)(value);
    let result;

    if ((0, _isGenerator.default)(value)) {
      result = yield* value;
    } else {
      result = yield value;
    }

    return yield* baseResolveToGeneratorWith(fn, result);
  }

  value = fn(value);

  if (!(0, _isResolved.baseIsResolved)(value)) {
    return yield* (0, _resolveToGenerator.baseResolveToGenerator)(value);
  }

  return value;
};
/**
 * Resolves a value to a generator using the generator to yield values. When the generator is complete the fn method is executed with the final result.
 *
 * @function
 * @since v0.0.11
 * @category common
 * @param {Function} fn The function to execute at the end of the generator's resolution
 * @param {*} value The value to resolve with the generator
 * @returns {Generator}
 * @example
 *
 * const generator = resolveToGeneratorWith(
 *   (resolvedValue) => //=> 'foo'
 *   'foo'
 * )
 * generator.next() //=> { done: true } triggers the fn method
 */


exports.baseResolveToGeneratorWith = baseResolveToGeneratorWith;
const resolveToGeneratorWith = (0, _curry.default)(baseResolveToGeneratorWith);
var _default = resolveToGeneratorWith;
exports.default = _default;
//# sourceMappingURL=resolveToGeneratorWith.js.map