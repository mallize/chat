{"version":3,"sources":["../../src/common/iterateRight.js"],"names":["resolveNext","next","fn","iter","recur","resolvedNext","done","value","doReverseSeriesIteration","previous","baseIterateRight","iteratee","collection","iterator","END","Error","iterateRight"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA,MAAMA,WAAW,GAAG,CAACC,IAAD,EAAOC,EAAP,EAAWC,IAAX,EAAiBC,KAAjB,KAClB,kCAAiBC,YAAD,IAAkB;AAChC,MAAIA,YAAY,CAACC,IAAjB,EAAuB;AACrB,WAAOD,YAAY,CAACE,KAApB;AACD;;AACD,SAAOH,KAAK,CAACF,EAAD,EAAKC,IAAL,CAAZ;AACD,CALD,EAKGF,IALH,CADF;;AAQA,MAAMO,wBAAwB,GAAG,CAACN,EAAD,EAAKC,IAAL,KAAc;AAC7C,SAAO,IAAP,EAAa;AACX,QAAIF,IAAI,GAAGE,IAAI,CAACM,QAAL,EAAX;;AACA,QAAI,CAAC,gCAAeR,IAAf,CAAL,EAA2B;AACzB,aAAO,kCAAiBI,YAAD,IAAkB;AACvCJ,QAAAA,IAAI,GAAGC,EAAE,CAACG,YAAD,CAAT;;AACA,YAAI,CAAC,gCAAeJ,IAAf,CAAL,EAA2B;AACzB,iBAAOD,WAAW,CAACC,IAAD,EAAOC,EAAP,EAAWC,IAAX,EAAiBK,wBAAjB,CAAlB;AACD;;AACD,YAAIP,IAAI,CAACK,IAAT,EAAe;AACb,iBAAOL,IAAI,CAACM,KAAZ;AACD;;AACD,eAAOC,wBAAwB,CAACN,EAAD,EAAKC,IAAL,CAA/B;AACD,OATM,EASJF,IATI,CAAP;AAUD;;AACDA,IAAAA,IAAI,GAAGC,EAAE,CAACD,IAAD,CAAT;;AACA,QAAI,CAAC,gCAAeA,IAAf,CAAL,EAA2B;AACzB,aAAOD,WAAW,CAACC,IAAD,EAAOC,EAAP,EAAWC,IAAX,EAAiBK,wBAAjB,CAAlB;AACD;;AACD,QAAIP,IAAI,CAACK,IAAT,EAAe;AACb,aAAOL,IAAI,CAACM,KAAZ;AACD;AACF;AACF,CAvBD;;AAyBA,MAAMG,gBAAgB,GAAG,CAACC,QAAD,EAAWC,UAAX,KAA0B;AACjD,QAAMT,IAAI,GAAG,4BAAaS,UAAb,EAAyBC,kBAASC,GAAlC,CAAb;;AACA,MAAI,CAAC,yBAAWX,IAAI,CAACM,QAAhB,CAAL,EAAgC;AAC9B,UAAM,IAAIM,KAAJ,CACH,iHAAgHZ,IAAK,EADlH,CAAN;AAGD;;AACD,SAAOK,wBAAwB,CAACG,QAAD,EAAWR,IAAX,CAA/B;AACD,CARD;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,MAAMa,YAAY,GAAG,oBAAMN,gBAAN,CAArB;eAEeM,Y","sourcesContent":["import { baseIsResolved } from './isResolved'\nimport { baseResolveWith } from './resolveWith'\nimport curry from './curry'\nimport isFunction from '../lang/isFunction'\nimport iterator, { baseIterator } from './iterator'\n\nconst resolveNext = (next, fn, iter, recur) =>\n  baseResolveWith((resolvedNext) => {\n    if (resolvedNext.done) {\n      return resolvedNext.value\n    }\n    return recur(fn, iter)\n  }, next)\n\nconst doReverseSeriesIteration = (fn, iter) => {\n  while (true) {\n    let next = iter.previous()\n    if (!baseIsResolved(next)) {\n      return baseResolveWith((resolvedNext) => {\n        next = fn(resolvedNext)\n        if (!baseIsResolved(next)) {\n          return resolveNext(next, fn, iter, doReverseSeriesIteration)\n        }\n        if (next.done) {\n          return next.value\n        }\n        return doReverseSeriesIteration(fn, iter)\n      }, next)\n    }\n    next = fn(next)\n    if (!baseIsResolved(next)) {\n      return resolveNext(next, fn, iter, doReverseSeriesIteration)\n    }\n    if (next.done) {\n      return next.value\n    }\n  }\n}\n\nconst baseIterateRight = (iteratee, collection) => {\n  const iter = baseIterator(collection, iterator.END)\n  if (!isFunction(iter.previous)) {\n    throw new Error(\n      `iterateRight expects an iterator that can be run in reverse order using a 'previous' method. Instead received ${iter}`\n    )\n  }\n  return doReverseSeriesIteration(iteratee, iter)\n}\n\n/**\n * This method iterates over the given collection or iterator in **series**. If the `iteratee` method returns `{ done: true }` then the iteration will complete.\n *\n * This method automatically upgrades to async. If the `iteratee` returns a Promise or a generator, this method will return a Promise or a generator. Values are iterated in order and if the iteratee returns a resolvable value the iteration will wait until that value resolves before continuing with the iteration.\n *\n * This method also supports async iterators. If an unresolved value is received from the iterator instead of an object with `value` and `done` properties, the iteration will wait for the value to resolve before continuing to the next iteration. This will also cause the method to upgrade to async and return a Promise.\n *\n * @function\n * @since v0.0.11\n * @category common\n * @param {Function} iteratee The iteratee Function\n * @param  {*} collection The collection or iterator to iterate over\n * @returns {*} The final value returned when the iteratee returns done or `undefined`\n * @example\n *\n * iterateRight((value, kdx) => {\n *   if (value === 'b') {\n *     return { done: true, value: kdx }\n *   }\n *   return { done: false }\n * }, ['a', 'b', 'c'])\n * //=> 1\n *\n * iterateRight(async (value, kdx) => new Promise((resolve, reject) => {\n *   setTimeout(() => {\n *     if (value === 'b') {\n *       return resolve({ done: true, value: kdx })\n *     }\n *     return resolve({ done: false })\n *   }, 0)\n * }), ['a', 'b', 'c'])\n * //=> 1\n */\nconst iterateRight = curry(baseIterateRight)\n\nexport default iterateRight\n\nexport { baseIterateRight }\n"],"file":"iterateRight.js"}