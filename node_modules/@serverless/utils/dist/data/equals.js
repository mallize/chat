"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.baseEquals = exports.default = void 0;

var _allWith = _interopRequireDefault(require("../common/allWith"));

var _arrayFromIterator = _interopRequireDefault(require("../lang/arrayFromIterator"));

var _containsWith = _interopRequireDefault(require("./containsWith"));

var _curry = _interopRequireDefault(require("../common/curry"));

var _has = _interopRequireDefault(require("./has"));

var _identical = _interopRequireDefault(require("../common/identical"));

var _keys = _interopRequireDefault(require("./keys"));

var _toFunctionName = _interopRequireDefault(require("../lang/toFunctionName"));

var _toType = _interopRequireDefault(require("../lang/toType"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * private _uniqContentEquals function.
 * That function is checking equality of 2 iterator contents with 2 assumptions
 * - iterators lengths are the same
 * - iterators values are unique
 *
 * false-positive result will be returned for comparision of, e.g.
 * - [1,2,3] and [1,2,3,4]
 * - [1,1,1] and [1,2,3]
 */
const uniqContentEquals = (aIterator, bIterator, stackA, stackB, equalsFn) => {
  const arrayA = (0, _arrayFromIterator.default)(aIterator);
  const arrayB = (0, _arrayFromIterator.default)(bIterator);

  function eq(_a, _b) {
    // TODO BRN: Why are we cloning the arrays here?
    return equalsFn(_a, _b, stackA.slice(), stackB.slice());
  } // if *a* array contains any element that is not included in *b*


  return !(0, _containsWith.default)(function (valueB, aItem) {
    return !(0, _containsWith.default)(eq, aItem, valueB);
  }, arrayB, arrayA);
};

const baseEquals = (valueA, valueB, stackA = [], stackB = []) => {
  if ((0, _identical.default)(valueA, valueB)) {
    return true;
  }

  const typeA = (0, _toType.default)(valueA);

  if (typeA !== (0, _toType.default)(valueB)) {
    return false;
  }

  if (valueA == null || valueB == null) {
    return false;
  }

  if (typeof valueA.equals === 'function' || typeof valueB.equals === 'function') {
    return typeof valueA.equals === 'function' && valueA.equals(valueB) && typeof valueB.equals === 'function' && valueB.equals(valueA);
  }

  switch (typeA) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof valueA.constructor === 'function' && (0, _toFunctionName.default)(valueA.constructor) === 'Promise') {
        return valueA === valueB;
      }

      break;

    case 'Boolean':
    case 'Date':
    case 'Number':
    case 'String':
      if (!(0, _identical.default)(valueA.valueOf(), valueB.valueOf())) {
        return false;
      }

      break;

    case 'Error':
      return valueA.name === valueB.name && valueA.message === valueB.message;

    case 'RegExp':
      if (!(valueA.source === valueB.source && valueA.global === valueB.global && valueA.ignoreCase === valueB.ignoreCase && valueA.multiline === valueB.multiline && valueA.sticky === valueB.sticky && valueA.unicode === valueB.unicode)) {
        return false;
      }

      break;
  }

  let idx = stackA.length - 1;

  while (idx >= 0) {
    if (stackA[idx] === valueA) {
      return stackB[idx] === valueB;
    }

    idx -= 1;
  }

  switch (typeA) {
    case 'Map':
      if (valueA.size !== valueB.size) {
        return false;
      }

      return uniqContentEquals(valueA.entries(), valueB.entries(), stackA.concat([valueA]), stackB.concat([valueB]), baseEquals);

    case 'Set':
      if (valueA.size !== valueB.size) {
        return false;
      }

      return uniqContentEquals(valueA.values(), valueB.values(), stackA.concat([valueA]), stackB.concat([valueB]), baseEquals);

    case 'Boolean':
      if (typeof valueA !== 'object') {
        valueA = new Boolean(valueA);
      }

      if (typeof valueB !== 'object') {
        valueB = new Boolean(valueB);
      }

    case 'Number':
      if (typeof valueA !== 'object') {
        valueA = new Number(valueA);
      }

      if (typeof valueB !== 'object') {
        valueB = new Number(valueB);
      }

    case 'String':
      if (typeof valueA !== 'object') {
        valueA = new String(valueA);
      }

      if (typeof valueB !== 'object') {
        valueB = new String(valueB);
      }

    case 'Arguments':
    case 'Array':
    case 'Object':
    case 'Date':
    case 'Error':
    case 'RegExp':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'ArrayBuffer':
      break;

    default:
      // Values of other types are only equal if identical.
      return false;
  }

  const keysA = (0, _keys.default)(valueA);

  if (keysA.length !== (0, _keys.default)(valueB).length) {
    return false;
  }

  const extendedStackA = stackA.concat([valueA]);
  const extendedStackB = stackB.concat([valueB]);
  idx = keysA.length - 1;

  while (idx >= 0) {
    const key = keysA[idx];

    if (!((0, _has.default)(key, valueB) && baseEquals(valueB[key], valueA[key], extendedStackA, extendedStackB))) {
      return false;
    }

    idx -= 1;
  }

  return true;
};
/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if present.
 *
 * @function
 * @since v0.0.18
 * @category data
 * @param {*} valueA
 * @param {*} valueB
 * @returns {boolean}
 * @example
 *
 * equals(1, 1)
 * //=> true
 *
 * equals(1, '1')
 * //=> false
 *
 * equals([1, 2, 3], [1, 2, 3])
 * //=> true
 *
 * const a = {}
 * a.v = a
 * const b = {}
 * b.v = b
 * equals(a, b)
 * //=> true
 */


exports.baseEquals = baseEquals;
const equals = (0, _curry.default)((valueA, valueB) => (0, _allWith.default)(([resolvedA, resolvedB]) => baseEquals(resolvedA, resolvedB), [valueA, valueB]));
var _default = equals;
exports.default = _default;
//# sourceMappingURL=equals.js.map