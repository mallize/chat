{"version":3,"sources":["../../src/data/walkReducePath.js"],"names":["reduceWalkee","pathParts","accum","value","keys","iteratee","recur","result","resolvedValue","length","nextKey","newKeys","walkReducePath","path","collection"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAEA,MAAMA,YAAY,GAAG,CAACC,SAAD,EAAYC,KAAZ,EAAmBC,KAAnB,EAA0BC,IAA1B,EAAgCC,QAAhC,EAA0CC,KAA1C,KACnB,mBACGC,MAAD,IAAYF,QAAQ,CAACE,MAAD,EAASJ,KAAT,EAAgBC,IAAhB,CADtB,EAEGG,MAAD,IAAY;AACV,QAAMC,aAAa,GAAG,sBAAQL,KAAR,CAAtB;;AACA,MAAIF,SAAS,CAACQ,MAAV,GAAmBL,IAAI,CAACK,MAAxB,IAAkC,uBAASD,aAAT,CAAtC,EAA+D;AAC7D,UAAME,OAAO,GAAGT,SAAS,CAACG,IAAI,CAACK,MAAN,CAAzB;AACA,UAAME,OAAO,GAAG,qBAAOD,OAAP,EAAgBN,IAAhB,CAAhB;AACAD,IAAAA,KAAK,GAAG,sBAAQA,KAAR,CAAR;AACA,WAAOG,KAAK,CAACL,SAAD,EAAYM,MAAZ,EAAoBC,aAAa,CAACE,OAAD,CAAjC,EAA4CC,OAA5C,EAAqDN,QAArD,CAAZ;AACD;;AACD,SAAOE,MAAP;AACD,CAXH,EAYEL,KAZF,CADF;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,MAAMU,cAAc,GAAG,oBAAM,CAACP,QAAD,EAAWQ,IAAX,EAAiBX,KAAjB,EAAwBY,UAAxB,KAC3B,mBAAKd,YAAL,EAAmBK,QAAnB,EAA6B,uBAASQ,IAAT,CAA7B,EAA6CX,KAA7C,EAAoDY,UAApD,EAAgE,EAAhE,CADqB,CAAvB;eAIeF,c","sourcesContent":["import append from './append'\nimport castPath from './castPath'\nimport curry from '../common/curry'\nimport isObject from '../lang/isObject'\nimport pipe from '../common/pipe'\nimport resolve from '../common/resolve'\nimport walk from './walk'\n\nconst reduceWalkee = (pathParts, accum, value, keys, iteratee, recur) =>\n  pipe(\n    (result) => iteratee(result, value, keys),\n    (result) => {\n      const resolvedValue = resolve(value)\n      if (pathParts.length > keys.length && isObject(resolvedValue)) {\n        const nextKey = pathParts[keys.length]\n        const newKeys = append(nextKey, keys)\n        value = resolve(value)\n        return recur(pathParts, result, resolvedValue[nextKey], newKeys, iteratee)\n      }\n      return result\n    }\n  )(accum)\n\n/**\n * Walk reduce the specific path using the given reducer function\n *\n * NOTE: This method will resolve values during the walk before walking them. However, the unresolved value will be delivered to the iteratee.\n *\n * @function\n * @since v0.0.6\n * @category data\n * @param {*} path The specific path to walk\n * @param {Function} fn The iterator function. Receives three values, the accumulator and the current element from the walk and the current set of keys from the entire depth of the walk.\n * @param {*} accum The accumulator value.\n * @param {*} collection The collection to walk.\n * @returns {*} The final, accumulated value.\n * @example\n *\n * walkReducePath(\n *   (accum, value, keys) => {\n *     return accum.push(keys)\n *   },\n *   'a.c.d'\n *   [],\n *   {\n *     a: {\n *       b: 'b',\n *       c: {\n *         d: 'd'\n *       }\n *     },\n *     e: [ 'e', 'f' ]\n *   }\n * )\n * //=> [\n * //   [],\n * //   ['a'],\n * //   ['a', 'c'],\n * //   ['a', 'c', 'd']\n * // ]\n */\nconst walkReducePath = curry((iteratee, path, accum, collection) =>\n  walk(reduceWalkee, iteratee, castPath(path), accum, collection, [])\n)\n\nexport default walkReducePath\n"],"file":"walkReducePath.js"}