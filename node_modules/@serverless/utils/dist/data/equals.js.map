{"version":3,"sources":["../../src/data/equals.js"],"names":["uniqContentEquals","aIterator","bIterator","stackA","stackB","equalsFn","arrayA","arrayB","eq","_a","_b","slice","valueB","aItem","baseEquals","valueA","typeA","equals","constructor","valueOf","name","message","source","global","ignoreCase","multiline","sticky","unicode","idx","length","size","entries","concat","values","Boolean","Number","String","keysA","extendedStackA","extendedStackB","key","resolvedA","resolvedB"],"mappings":"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","sourcesContent":["import allWith from '../common/allWith'\nimport arrayFromIterator from '../lang/arrayFromIterator'\nimport containsWith from './containsWith'\nimport curry from '../common/curry'\nimport has from './has'\nimport identical from '../common/identical'\nimport keys from './keys'\nimport toFunctionName from '../lang/toFunctionName'\nimport toType from '../lang/toType'\n\n/**\n * private _uniqContentEquals function.\n * That function is checking equality of 2 iterator contents with 2 assumptions\n * - iterators lengths are the same\n * - iterators values are unique\n *\n * false-positive result will be returned for comparision of, e.g.\n * - [1,2,3] and [1,2,3,4]\n * - [1,1,1] and [1,2,3]\n */\n\nconst uniqContentEquals = (aIterator, bIterator, stackA, stackB, equalsFn) => {\n  const arrayA = arrayFromIterator(aIterator)\n  const arrayB = arrayFromIterator(bIterator)\n\n  function eq(_a, _b) {\n    // TODO BRN: Why are we cloning the arrays here?\n    return equalsFn(_a, _b, stackA.slice(), stackB.slice())\n  }\n\n  // if *a* array contains any element that is not included in *b*\n  return !containsWith(\n    function(valueB, aItem) {\n      return !containsWith(eq, aItem, valueB)\n    },\n    arrayB,\n    arrayA\n  )\n}\n\nconst baseEquals = (valueA, valueB, stackA = [], stackB = []) => {\n  if (identical(valueA, valueB)) {\n    return true\n  }\n\n  const typeA = toType(valueA)\n\n  if (typeA !== toType(valueB)) {\n    return false\n  }\n\n  if (valueA == null || valueB == null) {\n    return false\n  }\n\n  if (typeof valueA.equals === 'function' || typeof valueB.equals === 'function') {\n    return (\n      typeof valueA.equals === 'function' &&\n      valueA.equals(valueB) &&\n      typeof valueB.equals === 'function' &&\n      valueB.equals(valueA)\n    )\n  }\n\n  switch (typeA) {\n    case 'Arguments':\n    case 'Array':\n    case 'Object':\n      if (\n        typeof valueA.constructor === 'function' &&\n        toFunctionName(valueA.constructor) === 'Promise'\n      ) {\n        return valueA === valueB\n      }\n      break\n    case 'Boolean':\n    case 'Date':\n    case 'Number':\n    case 'String':\n      if (!identical(valueA.valueOf(), valueB.valueOf())) {\n        return false\n      }\n      break\n    case 'Error':\n      return valueA.name === valueB.name && valueA.message === valueB.message\n    case 'RegExp':\n      if (\n        !(\n          valueA.source === valueB.source &&\n          valueA.global === valueB.global &&\n          valueA.ignoreCase === valueB.ignoreCase &&\n          valueA.multiline === valueB.multiline &&\n          valueA.sticky === valueB.sticky &&\n          valueA.unicode === valueB.unicode\n        )\n      ) {\n        return false\n      }\n      break\n  }\n\n  let idx = stackA.length - 1\n  while (idx >= 0) {\n    if (stackA[idx] === valueA) {\n      return stackB[idx] === valueB\n    }\n    idx -= 1\n  }\n\n  switch (typeA) {\n    case 'Map':\n      if (valueA.size !== valueB.size) {\n        return false\n      }\n\n      return uniqContentEquals(\n        valueA.entries(),\n        valueB.entries(),\n        stackA.concat([valueA]),\n        stackB.concat([valueB]),\n        baseEquals\n      )\n    case 'Set':\n      if (valueA.size !== valueB.size) {\n        return false\n      }\n\n      return uniqContentEquals(\n        valueA.values(),\n        valueB.values(),\n        stackA.concat([valueA]),\n        stackB.concat([valueB]),\n        baseEquals\n      )\n    case 'Boolean':\n      if (typeof valueA !== 'object') {\n        valueA = new Boolean(valueA)\n      }\n      if (typeof valueB !== 'object') {\n        valueB = new Boolean(valueB)\n      }\n    case 'Number':\n      if (typeof valueA !== 'object') {\n        valueA = new Number(valueA)\n      }\n      if (typeof valueB !== 'object') {\n        valueB = new Number(valueB)\n      }\n    case 'String':\n      if (typeof valueA !== 'object') {\n        valueA = new String(valueA)\n      }\n      if (typeof valueB !== 'object') {\n        valueB = new String(valueB)\n      }\n    case 'Arguments':\n    case 'Array':\n    case 'Object':\n    case 'Date':\n    case 'Error':\n    case 'RegExp':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'ArrayBuffer':\n      break\n    default:\n      // Values of other types are only equal if identical.\n      return false\n  }\n  const keysA = keys(valueA)\n  if (keysA.length !== keys(valueB).length) {\n    return false\n  }\n\n  const extendedStackA = stackA.concat([valueA])\n  const extendedStackB = stackB.concat([valueB])\n\n  idx = keysA.length - 1\n  while (idx >= 0) {\n    const key = keysA[idx]\n    if (\n      !(has(key, valueB) && baseEquals(valueB[key], valueA[key], extendedStackA, extendedStackB))\n    ) {\n      return false\n    }\n    idx -= 1\n  }\n  return true\n}\n\n/**\n * Returns `true` if its arguments are equivalent, `false` otherwise. Handles cyclical data structures.\n *\n * Dispatches symmetrically to the `equals` methods of both arguments, if present.\n *\n * @function\n * @since v0.0.18\n * @category data\n * @param {*} valueA\n * @param {*} valueB\n * @returns {boolean}\n * @example\n *\n * equals(1, 1)\n * //=> true\n *\n * equals(1, '1')\n * //=> false\n *\n * equals([1, 2, 3], [1, 2, 3])\n * //=> true\n *\n * const a = {}\n * a.v = a\n * const b = {}\n * b.v = b\n * equals(a, b)\n * //=> true\n */\nconst equals = curry((valueA, valueB) =>\n  allWith(([resolvedA, resolvedB]) => baseEquals(resolvedA, resolvedB), [valueA, valueB])\n)\n\nexport default equals\n\nexport { baseEquals }\n"],"file":"equals.js"}