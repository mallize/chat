"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchableAssocPath = exports.baseAssocPath = exports.default = void 0;

var _assocIndex = require("./assocIndex");

var _assocProp = require("./assocProp");

var _allWith = _interopRequireDefault(require("../common/allWith"));

var _curry = _interopRequireDefault(require("../common/curry"));

var _dispatchable = _interopRequireDefault(require("../common/dispatchable"));

var _has = _interopRequireDefault(require("./has"));

var _isArray = _interopRequireDefault(require("../lang/isArray"));

var _isInteger = _interopRequireDefault(require("../lang/isInteger"));

var _isNil = _interopRequireDefault(require("../lang/isNil"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const baseAssocPath = (path, value, collection) => {
  if (path.length === 0) {
    return value;
  }

  const _path = _slicedToArray(path, 1),
        part = _path[0];

  if (path.length > 1) {
    const nextCollection = !(0, _isNil.default)(collection) && (0, _has.default)(part, collection) ? collection[part] : (0, _isInteger.default)(path[1]) ? [] : {};
    value = baseAssocPath(Array.prototype.slice.call(path, 1), value, nextCollection);
  }

  if ((0, _isInteger.default)(part) && (0, _isArray.default)(collection)) {
    return (0, _assocIndex.baseAssocIndex)(part, value, collection);
  }

  return (0, _assocProp.baseAssocProp)(part, value, collection);
};

exports.baseAssocPath = baseAssocPath;
const dispatchableAssocPath = (0, _dispatchable.default)('assocPath', baseAssocPath);
/**
 * Makes a shallow clone of an object, setting or overriding the nodes required
 * to create the given path, and placing the specific value at the tail end of
 * that path. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 * @function
 * @since v0.0.3
 * @category data
 * @param {Array} path The path to set
 * @param {*} value The new value
 * @param {*} collection The collection to clone
 * @returns {*} A new collection equivalent to the original except along the specified path.
 * @example
 *
 * assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}) //=> {a: {b: {c: 42}}}
 *
 * // Any missing or non-object keys in path will be overridden
 * assocPath(['a', 0, 'c'], 42, {a: 5}) //=> {a: [{c: 42}]}
 */

exports.dispatchableAssocPath = dispatchableAssocPath;
const assocPath = (0, _curry.default)((path, value, collection) => (0, _allWith.default)(([resolvedPath, resolvedCollection]) => dispatchableAssocPath(resolvedPath, value, resolvedCollection), [path, collection]));
var _default = assocPath;
exports.default = _default;
//# sourceMappingURL=assocPath.js.map