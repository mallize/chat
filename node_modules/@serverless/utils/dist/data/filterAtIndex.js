"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _concat = _interopRequireDefault(require("./concat"));

var _curry = _interopRequireDefault(require("../common/curry"));

var _defn = _interopRequireDefault(require("../common/defn"));

var _errorUnexpectedType = _interopRequireDefault(require("./errors/errorUnexpectedType"));

var _isArrayLike = _interopRequireDefault(require("../lang/isArrayLike"));

var _isPromise = _interopRequireDefault(require("../lang/isPromise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the same type containing the members of the given filterable which satisfy the given predicate starting from the given index. Filterable objects include plain objects or any object that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Supports async predicates. If a predicate returns a Promise than the entire method will upgrade to async and return a Promise.
 *
 * @function
 * @since v0.0.6
 * @category data
 * @param {Function} fn The predicate function.
 * @param {Integer} index The index to start at.
 * @param {Array} list The array to consider.
 * @returns {Array} The filtered list
 * @example
 *
 * const isEven = n => n % 2 === 0;
 *
 * filterAtIndex(isEven, 0, [1, 2, 3, 4]) //=> [2, 4]
 * filterAtIndex(isEven, 2, [1, 2, 3, 4]) //=> [4]
 *
 * await filter(async (value) => isEven(value), [1, 2, 3, 4]) //=> [2, 4]
 */
const filterAtIndex = (0, _curry.default)((0, _defn.default)('filterAtIndex', (fn, index, list) => {
  if (!(0, _isArrayLike.default)(list)) {
    throw (0, _errorUnexpectedType.default)('ArrayLike', list);
  }

  const length = list.length;
  let idx = index || 0;

  if (idx < 0) {
    idx = length + idx;
  }

  if (idx < 0) {
    idx = 0;
  }

  const filtered = [];

  while (idx < length) {
    const result = fn(list[idx], idx);

    if ((0, _isPromise.default)(result)) {
      return result.then(resolvedResult => {
        if (resolvedResult) {
          filtered.push(list[idx]);
        }

        return (0, _concat.default)(filtered, filterAtIndex(fn, idx + 1, list));
      });
    } else if (result) {
      filtered.push(list[idx]);
    }

    idx += 1;
  }

  return filtered;
}));
var _default = filterAtIndex;
exports.default = _default;
//# sourceMappingURL=filterAtIndex.js.map