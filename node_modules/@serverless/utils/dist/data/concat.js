"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _curry = _interopRequireDefault(require("../common/curry"));

var _defn = _interopRequireDefault(require("../common/defn"));

var _isArray = _interopRequireDefault(require("../lang/isArray"));

var _isFunction = _interopRequireDefault(require("../lang/isFunction"));

var _isString = _interopRequireDefault(require("../lang/isString"));

var _toString = _interopRequireDefault(require("../lang/toString"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: `concat` expects both arguments to be of the same type, unlike the native `Array.prototype.concat` method. It will throw an error if you `concat` an Array with a non-Array value.
 *
 * Dispatches to the `concat` method of the first argument, if present.
 *
 * Supports Promises. If a Promise is received for either parameter than the entire method will upgrade to async and return a Promise.
 *
 * @function
 * @since v0.0.6
 * @category data
 * @param {Array|string|Promise} firstList The first list
 * @param {Array|string|Promise} secondList The second list
 * @returns {Array|string} A list consisting of the elements of `firstList` followed by the elements of `secondList`.
 *
 * @example
 *
 * concat('ABC', 'DEF') // 'ABCDEF'
 * concat([4, 5, 6], [1, 2, 3]) //=> [4, 5, 6, 1, 2, 3]
 * concat([], []) //=> []
 * await concat(Promise.resolve([4, 5, 6]), Promise.resolve([1, 2, 3])) //=> [4, 5, 6, 1, 2, 3]
 */
const concat = (0, _curry.default)((0, _defn.default)('concat', (firstList, secondList) => {
  // TODO BRN: Add support for concatenating more than one list
  if ((0, _isArray.default)(firstList)) {
    if ((0, _isArray.default)(secondList)) {
      return firstList.concat(secondList);
    }

    throw new TypeError(`${(0, _toString.default)(secondList)} is not an array`);
  }

  if ((0, _isString.default)(firstList)) {
    if ((0, _isString.default)(secondList)) {
      return firstList + secondList;
    }

    throw new TypeError(`${(0, _toString.default)(secondList)} is not a string`);
  }

  if (firstList != null && (0, _isFunction.default)(firstList.concat)) {
    return firstList.concat(secondList);
  }

  throw new TypeError(`${(0, _toString.default)(firstList)} does not have a method named "concat"`);
}));
var _default = concat;
exports.default = _default;
//# sourceMappingURL=concat.js.map