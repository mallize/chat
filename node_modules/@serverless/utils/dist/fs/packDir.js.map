{"version":3,"sources":["../../src/fs/packDir.js"],"names":["VALID_FORMATS","isValidFormat","format","packDir","inputDirPath","outputFilePath","append","Error","ignore","path","join","Promise","resolve","reject","output","archive","zlib","level","on","pipe","file","stream","name","basename","date","Date","glob","cwd","finalize","err"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAEA,MAAMA,aAAa,GAAG,CAAC,KAAD,EAAQ,KAAR,CAAtB;;AACA,MAAMC,aAAa,GAAIC,MAAD,IAAY,uBAASA,MAAT,EAAiBF,aAAjB,CAAlC;;AAEA,MAAMG,OAAO,GAAG,qBAAO,CAAP;AAAA;AAAA;AAAA,+BAAU,WAAOC,YAAP,EAAqBC,cAArB,EAAqCC,MAAM,GAAG,EAA9C,EAAqD;AAC7E,UAAMJ,MAAM,GAAG,mBAAK,oBAAM,GAAN,EAAWG,cAAX,CAAL,CAAf;;AAEA,QAAI,CAACJ,aAAa,CAACC,MAAD,CAAlB,EAA4B;AAC1B,YAAM,IAAIK,KAAJ,CAAU,0DAAV,CAAN;AACD;;AAED,UAAMC,MAAM,GAAG,OAAO,+BAAiBC,cAAKC,IAAL,CAAUN,YAAV,EAAwB,YAAxB,CAAjB,CAAP,KAAmE,EAAlF;AACA,WAAO,IAAIO,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,YAAMC,MAAM,GAAG,gCAAkBT,cAAlB,CAAf;AACA,YAAMU,OAAO,GAAG,uBAASb,MAAT,EAAiB;AAC/Bc,QAAAA,IAAI,EAAE;AAAEC,UAAAA,KAAK,EAAE;AAAT;AADyB,OAAjB,CAAhB;AAIAH,MAAAA,MAAM,CAACI,EAAP,CAAU,MAAV,EAAkB,MAAM;AACtBH,QAAAA,OAAO,CAACI,IAAR,CAAaL,MAAb;;AAEA,YAAI,CAAC,sBAAQR,MAAR,CAAL,EAAsB;AACpB,gCAASc,IAAD,IAAU;AAChB,kBAAMC,MAAM,GAAG,+BAAiBD,IAAjB,CAAf;AACAL,YAAAA,OAAO,CAACT,MAAR,CAAee,MAAf,EAAuB;AAAEC,cAAAA,IAAI,EAAEb,cAAKc,QAAL,CAAcH,IAAd,CAAR;AAA6BI,cAAAA,IAAI,EAAE,IAAIC,IAAJ,CAAS,CAAT;AAAnC,aAAvB;AACD,WAHD,EAGGnB,MAHH;AAID;;AAEDS,QAAAA,OAAO,CAACW,IAAR,CACE,MADF,EAEE;AACEC,UAAAA,GAAG,EAAEvB,YADP;AAEEI,UAAAA;AAFF,SAFF,EAME,EANF;AAQAO,QAAAA,OAAO,CAACa,QAAR;AACD,OAnBD;AAqBAb,MAAAA,OAAO,CAACG,EAAR,CAAW,OAAX,EAAqBW,GAAD,IAAShB,MAAM,CAACgB,GAAD,CAAnC;AACAf,MAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmB,MAAMN,OAAO,CAACP,cAAD,CAAhC;AACD,KA7BM,CAAP;AA8BD,GAtCe;;AAAA;AAAA;AAAA;AAAA,IAAhB;eAwCeF,O","sourcesContent":["import { createReadStream, createWriteStream } from 'fs-extra'\nimport archiver from 'archiver'\nimport contains from '../data/contains'\nimport curryN from '../common/curryN'\nimport forEach from '../data/forEach'\nimport isEmpty from '../logic/isEmpty'\nimport last from '../data/last'\nimport path from 'path'\nimport readFileIfExists from './readFileIfExists'\nimport split from '../data/split'\n\nconst VALID_FORMATS = ['zip', 'tar']\nconst isValidFormat = (format) => contains(format, VALID_FORMATS)\n\nconst packDir = curryN(2, async (inputDirPath, outputFilePath, append = []) => {\n  const format = last(split('.', outputFilePath))\n\n  if (!isValidFormat(format)) {\n    throw new Error('Please provide a valid format. Either a \"zip\" or a \"tar\"')\n  }\n\n  const ignore = (await readFileIfExists(path.join(inputDirPath, '.slsignore'))) || []\n  return new Promise((resolve, reject) => {\n    const output = createWriteStream(outputFilePath)\n    const archive = archiver(format, {\n      zlib: { level: 9 }\n    })\n\n    output.on('open', () => {\n      archive.pipe(output)\n\n      if (!isEmpty(append)) {\n        forEach((file) => {\n          const stream = createReadStream(file)\n          archive.append(stream, { name: path.basename(file), date: new Date(0) })\n        }, append)\n      }\n\n      archive.glob(\n        '**/*',\n        {\n          cwd: inputDirPath,\n          ignore\n        },\n        {}\n      )\n      archive.finalize()\n    })\n\n    archive.on('error', (err) => reject(err))\n    output.on('close', () => resolve(outputFilePath))\n  })\n})\n\nexport default packDir\n"],"file":"packDir.js"}